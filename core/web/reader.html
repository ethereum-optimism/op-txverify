<!DOCTYPE html>
<html>
<head>
    <title>op-verify writer</title>
    <style>
        /* Base styles */
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            text-align: center; 
            margin: 0; 
            padding: 20px; 
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        /* Layout */
        .container { 
            width: 700px; /* Increased from max-width: 640px */
            margin: 0 auto;
            background-color: #1e1e1e;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            position: relative;
        }
        
        /* Shards container */
        .shards-container {
            position: relative;
            width: 650px; /* Increased from 500px */
            height: 650px; /* Increased from 500px */
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Circular scanner container */
        #scanbot-camera-container {
            width: 420px;
            height: 420px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            overflow: hidden;
            border-radius: 50%;
            border: 4px solid #FF0420;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1;
        }
        
        /* Scan animation */
        .scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(to right, transparent, #FF0420, transparent);
            animation: scan 2s linear infinite;
            z-index: 10;
            pointer-events: none;
        }
        
        /* Scanner glow effect */
        .scanner-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 420px;  /* Match the camera container size */
            height: 420px; /* Match the camera container size */
            border-radius: 50%;
            box-shadow: 0 0 60px rgba(255, 4, 32, 0.4); /* Increased shadow size instead of element size */
            animation: pulse-glow 2s infinite ease-in-out;
            z-index: 0;
        }
        
        .scanner-glow.active {
            opacity: 1;
        }
        
        /* Solid red circle that replaces scanner after completion */
        .completion-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 424px;
            height: 424px;
            border-radius: 50%;
            background-color: #FF0420;
            z-index: 2;
            display: none;
        }
        
        /* Individual shard */
        .shard {
            position: absolute;
            width: 90px;
            height: 100px;
            background-color: #333333;
            clip-path: polygon(50% 0, 90% 50%, 50% 100%, 10% 50%);
            display: flex;
            justify-content: center;
            align-items: center;
            color: transparent;
            z-index: 0;
            transform-origin: center;
            transition: left 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                        top 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                        background-color 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                        color 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .shard.received {
            background-color: #FF0420;
            color: white;
            box-shadow: 0 4px 8px rgba(255, 4, 32, 0.3);
        }
        
        .shard.latest {
            animation: pulse 250ms 1 ease-in-out;
            box-shadow: 0 0 15px rgba(255, 4, 32, 0.6);
        }
        
        .shard.rescanned {
            animation: pulse 250ms 1 ease-in-out;
            box-shadow: 0 0 15px rgba(255, 4, 32, 0.6);
        }
        
        /* Animations */
        @keyframes pulse {
            0% { transform: rotate(var(--rotation-angle)) scale(1); }
            50% { transform: rotate(var(--rotation-angle)) scale(1.15); }
            100% { transform: rotate(var(--rotation-angle)) scale(1); }
        }
        
        @keyframes scan {
            0% { top: 0; }
            100% { top: 100%; }
        }
        
        @keyframes pulse-glow {
            0% { opacity: 0.3; box-shadow: 0 0 40px rgba(255, 4, 32, 0.3); }
            50% { opacity: 0.9; box-shadow: 0 0 60px rgba(255, 4, 32, 0.5); } /* Much larger glow */
            100% { opacity: 0.3; box-shadow: 0 0 40px rgba(255, 4, 32, 0.3); }
        }
    </style>
    <!-- External libraries -->
    <script src="/lib/scanbot/ScanbotSDK.ui2.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="shards-container">
            <div id="scanbot-camera-container">
                <div class="scan-line"></div>
            </div>
            <div class="scanner-glow"></div>
            <div class="completion-circle"></div>
            <div id="shards-container"></div>
        </div>
    </div>

    <script>
        /**
         * QR Code Reader Application
         * 
         * This script handles scanning QR codes to receive and reassemble chunked data.
         * It uses the Scanbot SDK for QR code scanning and Web Crypto API for verification.
         */
        
        // Configuration constants
        const CONFIG = {
            LICENSE_KEY: "", // Replace with your Scanbot license key if you have one
            ENGINE_PATH: "/lib/scanbot/engine/"
        };
        
        // DOM element references
        const DOM = {
            shardsContainer: document.getElementById('shards-container'),
            cameraContainer: document.getElementById('scanbot-camera-container'),
            scannerGlow: document.querySelector('.scanner-glow'),
            completionCircle: document.querySelector('.completion-circle')
        };
        
        // Application state
        const state = {
            transferId: null,
            receivedParts: {},
            totalParts: 0,
            lastScanned: "",
            scanbotSDK: null,
            barcodeScanner: null,
            fullData: null,
            expectedFullChecksum: null,
            latestReceivedPart: null
        };
        
        /**
         * Utility Functions
         */
        
        // Calculate SHA-256 hash using Web Crypto API
        async function calculateSHA256(str) {
            // Convert string to ArrayBuffer
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            
            // Calculate hash
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            
            // Convert to hex string
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            return hashHex;
        }
        
        /**
         * Initialization Functions
         */
        
        // Initialize the Scanbot SDK
        async function initializeScanner() {
            try {
                // Initialize the SDK
                state.scanbotSDK = await ScanbotSDK.initialize({
                    licenseKey: CONFIG.LICENSE_KEY,
                    enginePath: CONFIG.ENGINE_PATH,
                });
                
                // Create a barcode scanner
                state.barcodeScanner = await state.scanbotSDK.createBarcodeScanner({
                    containerId: "scanbot-camera-container",
                    onBarcodesDetected: handleBarcodesDetected,
                    barcodeFormats: ["QR_CODE"],
                    preferredCamera: "environment",
                    captureDelay: 10,
                    userGuidance: {
                        visible: false
                    }
                });
            } catch (error) {
                console.error("Error initializing Scanbot SDK:", error);
            }
        }
        
        /**
         * UI Functions
         */
        
        // Create visual shard indicators for chunks
        function createShardIndicators(count) {
            DOM.shardsContainer.innerHTML = '';
            
            // Calculate positions in a circle around the scanner
            const radius = 280;
            const centerX = 325;
            const centerY = 325;
            
            for (let i = 1; i <= count; i++) {
                const angle = ((i - 1) / count) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle) - 45;
                const y = centerY + radius * Math.sin(angle) - 50;
                
                const shard = document.createElement('div');
                shard.className = 'shard';
                shard.dataset.part = i;
                shard.dataset.angle = angle; // Store the angle for later use
                shard.style.left = `${x}px`;
                shard.style.top = `${y}px`;
                
                // Rotate the shard to point toward the center
                const rotationDeg = (angle * 180 / Math.PI) + 90;
                shard.style.setProperty('--rotation-angle', `${rotationDeg}deg`);
                shard.style.transform = `rotate(${rotationDeg}deg)`;
                
                DOM.shardsContainer.appendChild(shard);
            }
        }
        
        // Update shard indicators based on received parts
        function updateShardIndicators(isRescan = false) {
            const shards = DOM.shardsContainer.querySelectorAll('.shard');
            
            shards.forEach(shard => {
                const part = parseInt(shard.dataset.part);
                const angle = parseFloat(shard.dataset.angle);
                
                // Calculate the rotation (same for all states)
                const rotationDeg = (angle * 180 / Math.PI) + 90;
                
                // Set the rotation as a CSS variable for use in animations
                shard.style.setProperty('--rotation-angle', `${rotationDeg}deg`);
                
                // Apply rotation immediately without transition
                shard.style.transform = `rotate(${rotationDeg}deg)`;
                
                // Remove any previous "latest" or "rescanned" class
                shard.classList.remove('latest');
                shard.classList.remove('rescanned');
                
                // Mark received parts
                if (state.receivedParts[part]) {
                    shard.classList.add('received');
                    
                    // Calculate positions
                    const inwardRadius = 210;
                    const centerX = 325;
                    const centerY = 325;
                    
                    // Calculate new position (closer to center)
                    const x = centerX + inwardRadius * Math.cos(angle) - 45;
                    const y = centerY + inwardRadius * Math.sin(angle) - 50;
                    
                    // Update position to move inward
                    shard.style.left = `${x}px`;
                    shard.style.top = `${y}px`;
                    
                    // Mark the latest received part
                    if (part === state.latestReceivedPart) {
                        // If this is a rescan, use the rescanned class instead of latest
                        if (isRescan) {
                            shard.classList.add('rescanned');
                        } else {
                            shard.classList.add('latest');
                        }
                    }
                } else {
                    // Reset position for unreceived shards
                    const radius = 280;
                    const centerX = 325;
                    const centerY = 325;
                    
                    // Calculate original position
                    const x = centerX + radius * Math.cos(angle) - 45;
                    const y = centerY + radius * Math.sin(angle) - 50;
                    
                    // Reset to original position
                    shard.style.left = `${x}px`;
                    shard.style.top = `${y}px`;
                }
            });
        }
        
        /**
         * Data Processing Functions
         */
        
        // Handle detected barcodes
        async function handleBarcodesDetected(result) {
            if (!result.barcodes || result.barcodes.length === 0) return;
            
            // Get the first detected QR code
            const barcode = result.barcodes[0];
            const decodedText = barcode.text;
            
            // Skip if this is the same QR code we just processed
            if (decodedText === state.lastScanned) return;
            
            state.lastScanned = decodedText;

            console.log("QR Code detected:", decodedText);
            
            try {
                // Parse the QR code data
                const qrData = JSON.parse(decodedText);
                
                // Validate the QR code format
                if (!qrData.id || !qrData.part || !qrData.total || !qrData.data || 
                    !qrData.checksum || !qrData.fullChecksum) {
                    return;
                }
                
                // Set transfer ID if this is the first part we're seeing
                if (!state.transferId) {
                    state.transferId = qrData.id;
                    state.totalParts = qrData.total;
                    state.expectedFullChecksum = qrData.fullChecksum;
                    // Create shard indicators when we first learn how many parts there are
                    createShardIndicators(state.totalParts);
                } else if (state.transferId !== qrData.id) {
                    resetTransfer();
                    state.transferId = qrData.id;
                    state.totalParts = qrData.total;
                    state.expectedFullChecksum = qrData.fullChecksum;
                    // Create new shard indicators for the new transfer
                    createShardIndicators(state.totalParts);
                }
                
                // Verify the part's checksum
                const calculatedChecksum = await calculateSHA256(qrData.data);
                if (calculatedChecksum !== qrData.checksum) {
                    return;
                }
                
                // Store the part if we don't have it yet
                if (!state.receivedParts[qrData.part]) {
                    state.receivedParts[qrData.part] = qrData.data;
                    state.latestReceivedPart = qrData.part;
                    
                    // Update shard indicators
                    updateShardIndicators();
                    
                    // Check if we have all parts
                    const receivedCount = Object.keys(state.receivedParts).length;
                    if (receivedCount === state.totalParts) {
                        await assembleAndVerifyData();
                    }
                } else {
                    // We already have this part, but we'll highlight it as rescanned
                    state.latestReceivedPart = qrData.part;
                    updateShardIndicators(true); // Pass true to indicate this is a rescan
                }
            } catch (error) {
                console.error("Error processing QR code:", error);
            }
        }
        
        // Assemble and verify the complete data
        async function assembleAndVerifyData() {
            // Assemble the data in the correct order
            const orderedParts = [];
            for (let i = 1; i <= state.totalParts; i++) {
                if (!state.receivedParts[i]) {
                    return;
                }
                orderedParts.push(state.receivedParts[i]);
            }
            
            // Combine all parts
            const combinedData = orderedParts.join('');
            
            // Verify the full data checksum
            const calculatedFullChecksum = await calculateSHA256(combinedData);
            if (calculatedFullChecksum !== state.expectedFullChecksum) {
                return;
            }
            
            // Data is valid, decode from base64
            try {
                state.fullData = atob(combinedData);
                
                // Stop the scanner
                if (state.barcodeScanner) {
                    state.barcodeScanner.dispose();
                }
                
                // Replace scanner view with solid red circle
                DOM.cameraContainer.style.display = 'none';
                DOM.scannerGlow.style.display = 'none';
                DOM.completionCircle.style.display = 'block';
                
                // Send the result to the server
                sendResultToServer(state.fullData);
            } catch (error) {
                console.error("Error decoding data:", error);
            }
        }
        
        // Send the assembled data to the server
        function sendResultToServer(data) {
            fetch('/result', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: 'data=' + encodeURIComponent(data)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    setTimeout(() => window.close(), 1000);
                } else {
                    console.error('Server error:', data.message || 'Unknown error');
                }
            })
            .catch(err => {
                console.error('Error sending result:', err);
            });
        }
        
        // Reset the transfer state
        function resetTransfer() {
            state.transferId = null;
            state.receivedParts = {};
            state.totalParts = 0;
            state.fullData = null;
            state.expectedFullChecksum = null;
            state.latestReceivedPart = null;
            DOM.shardsContainer.innerHTML = ''; // Clear shards
        }
        
        /**
         * Event Handlers
         */
        
        // Initialize the scanner when the page loads
        window.addEventListener('DOMContentLoaded', initializeScanner);
        
        // Clean up when the page is closed
        window.addEventListener('beforeunload', () => {
            if (state.barcodeScanner) {
                state.barcodeScanner.dispose();
            }
        });
    </script>
</body>
</html>