<!DOCTYPE html>
<html>
<head>
    <title>op-verify reader</title>
    <style>
        /* Base styles */
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            text-align: center; 
            margin: 0; 
            padding: 20px; 
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        /* Layout */
        .container { 
            width: 700px; /* Increased from max-width: 640px */
            margin: 0 auto;
            background-color: #1e1e1e;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            position: relative;
        }
        
        /* Shards container */
        .shards-container {
            position: relative;
            width: 650px; /* Increased from 500px */
            height: 650px; /* Increased from 500px */
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Circular scanner container */
        #scanbot-camera-container {
            width: 420px;
            height: 420px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            overflow: hidden;
            border-radius: 50%;
            border: 4px solid #FF0420;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1;
        }
        
        /* Scan animation */
        .scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(to right, transparent, #FF0420, transparent);
            animation: scan 2s linear infinite;
            z-index: 10;
            pointer-events: none;
        }
        
        /* Scanner glow effect */
        .scanner-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 420px;  /* Match the camera container size */
            height: 420px; /* Match the camera container size */
            border-radius: 50%;
            box-shadow: 0 0 60px rgba(255, 4, 32, 0.4); /* Increased shadow size instead of element size */
            animation: pulse-glow 2s infinite ease-in-out;
            z-index: 0;
        }
        
        .scanner-glow.active {
            opacity: 1;
        }
        
        /* Solid red circle that replaces scanner after completion */
        .completion-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 424px;
            height: 424px;
            border-radius: 50%;
            background-color: #FF0420;
            z-index: 2;
            display: none;
            /* Add flexbox properties to center the image */
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        /* Style for the Sunny image */
        .sunny-image {
            width: 200px;
            height: auto;
            z-index: 3;
            margin-top: 0px;
        }
        
        /* Success message styling */
        .success-message {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        /* Individual shard */
        .shard {
            position: absolute;
            width: 100px;
            height: 100px;
            background-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            color: transparent;
            z-index: 0;
            transform-origin: center;
            transition: left 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                        top 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                        background-color 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                        color 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        /* Add a pseudo-element to create the diamond shape */
        .shard::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #333333;
            /* Add skew to the rotation transform */
            transform: rotate(45deg) skew(10deg, 10deg);
            z-index: -1;
            transition: background-color 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .shard.received::before {
            background-color: #FF0420;
        }
        
        .shard.received {
            color: white;
        }
        
        .shard.latest::before {
            box-shadow: 0 0 15px rgba(255, 4, 32, 0.6);
        }
        
        .shard.rescanned::before {
            box-shadow: 0 0 15px rgba(255, 4, 32, 0.6);
        }
        
        /* Animations */
        @keyframes pulse {
            0% { transform: rotate(var(--rotation-angle)) scale(1); }
            50% { transform: rotate(var(--rotation-angle)) scale(1.15); }
            100% { transform: rotate(var(--rotation-angle)) scale(1); }
        }
        
        @keyframes scan {
            0% { top: 0; }
            100% { top: 100%; }
        }
        
        @keyframes pulse-glow {
            0% { opacity: 0.3; box-shadow: 0 0 40px rgba(255, 4, 32, 0.3); }
            50% { opacity: 0.9; box-shadow: 0 0 60px rgba(255, 4, 32, 0.5); } /* Much larger glow */
            100% { opacity: 0.3; box-shadow: 0 0 40px rgba(255, 4, 32, 0.3); }
        }
        
        @keyframes bounce {
            0% { transform: rotate(var(--rotation-angle)) translateY(0); }
            40% { transform: rotate(var(--rotation-angle)) translateY(-15px); }
            60% { transform: rotate(var(--rotation-angle)) translateY(-7px); }
            80% { transform: rotate(var(--rotation-angle)) translateY(-3px); }
            100% { transform: rotate(var(--rotation-angle)) translateY(0); }
        }
    </style>

    <!-- External libraries first -->
    <script src="./lib/qrscanner.js"></script>
    <script src="./lib/fflate.js"></script>
    <script src="./lib/erasure.js"></script>
    <script src="./lib/ethers.js"></script>
    
    <!-- Utility JavaScript in dependency order -->
    <script src="./core/constants.js"></script>
    <script src="./core/hashing.js"></script>
    <script src="./core/parsing.js"></script>
    <script src="./core/verification.js"></script>
    <script src="./core/formatting.js"></script>
    <script src="./core/ui.js"></script>
</head>
<body>
    <div class="container">
        <div class="shards-container">
            <div id="scanbot-camera-container">
                <div class="scan-line"></div>
            </div>
            <div class="scanner-glow"></div>
            <div class="completion-circle">
                <img src="./assets/sunny.png" alt="Sunny" class="sunny-image">
                <div class="success-message">Scan successful! Results below.</div>
            </div>
            <div id="shards-container"></div>
        </div>
        <div id="verification-result"></div>
    </div>

    <script>
        /**
         * QR Code Reader Application
         * 
         * This application scans QR codes to reassemble secret data using Shamir's Secret Sharing.
         * When sufficient shares are collected, it reconstructs and verifies the original data.
         */
        
        // ===== CONSTANTS =====
        const CONFIG = {
            // No configuration needed for qr-scanner UMD
        };

        const LAYOUT = {
            CENTER_X: 320,
            CENTER_Y: 325,
            INNER_RADIUS: 100,  // Initial radius for shards
            OUTER_RADIUS: 200,  // Final radius for scanned shards
            SHARD_OFFSET_X: 45, // Offset for positioning shards
            SHARD_OFFSET_Y: 50  // Offset for positioning shards
        };

        // ===== DOM ELEMENTS =====
        const DOM = {
            shardsContainer: document.getElementById('shards-container'),
            cameraContainer: document.getElementById('scanbot-camera-container'),
            scannerGlow: document.querySelector('.scanner-glow'),
            completionCircle: document.querySelector('.completion-circle'),
            verificationResult: document.getElementById('verification-result')
        };

        // ===== APPLICATION STATE =====
        const state = {
            transferId: null,        // Unique ID for the current transfer
            receivedShares: {},      // Format: {partNumber: shareData}
            originalBlobs: 0,        // Number of shards needed for reconstruction
            allowedFailures: 0,      // Number of failures allowed by erasure coding
            totalShares: 0,          // Total shares in the transaction
            lastScanned: "",         // Text of last scanned QR code
            qrScanner: null,         // Reference to QR Scanner
            fullData: null,          // Reconstructed data
            expectedFullChecksum: null, // Checksum of full data
            latestReceivedPart: null,  // Last received part
            originalSize: 0          // Original size of data
        };
        
        // ===== UTILITY FUNCTIONS =====
        
        /**
         * Calculates SHA-256 hash of a string
         * @param {string} str - String to hash
         * @returns {Promise<string>} Hex string of SHA-256 hash
         */
        async function calculateSHA256(str) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hashBuffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        /**
         * Converts a base64 string to Uint8Array
         * @param {string} base64 - Base64 encoded string
         * @returns {Uint8Array} Decoded bytes
         */
        function base64ToUint8Array(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }
        
        /**
         * Converts a Uint8Array to base64 string
         * @param {Uint8Array} uint8Array - Byte array to encode
         * @returns {string} Base64 encoded string
         */
        function uint8ArrayToBase64(uint8Array) {
            let binary = '';
            const bytes = new Uint8Array(uint8Array);
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        
        // ===== INITIALIZATION =====
        
        /**
         * Initializes the QR Scanner
         */
        async function initializeScanner() {
            try {
                // Create video element for the scanner
                const videoElem = document.createElement('video');
                videoElem.style.width = '100%';
                videoElem.style.height = '100%';
                videoElem.style.objectFit = 'cover';
                DOM.cameraContainer.appendChild(videoElem);
                
                // Create QR scanner instance with UMD version
                state.qrScanner = new QrScanner(
                    videoElem, 
                    handleQrScan,
                    {
                        returnDetailedScanResult: true,
                        preferredCamera: 'environment',
                        maxScansPerSecond: 10,
                        highlightScanRegion: true,
                        highlightCodeOutline: true
                    }
                );
                
                // Start scanning
                await state.qrScanner.start();
            } catch (error) {
                console.error("Error initializing QR Scanner:", error);
            }
        }

        // ===== UI FUNCTIONS =====

        /**
         * Creates visual shard indicators arranged in a circle
         * @param {number} count - Number of shards to create
         */
        function createShardIndicators(count) {
            DOM.shardsContainer.innerHTML = '';
            
            for (let i = 1; i <= count; i++) {
                const angle = ((i - 1) / count) * 2 * Math.PI;
                
                // Calculate initial position
                const x = LAYOUT.CENTER_X + LAYOUT.INNER_RADIUS * Math.cos(angle) - LAYOUT.SHARD_OFFSET_X;
                const y = LAYOUT.CENTER_Y + LAYOUT.INNER_RADIUS * Math.sin(angle) - LAYOUT.SHARD_OFFSET_Y;
                
                const shard = document.createElement('div');
                shard.className = 'shard';
                shard.dataset.part = i;
                shard.dataset.angle = angle;
                shard.style.left = `${x}px`;
                shard.style.top = `${y}px`;
                
                // Rotate to point outward
                const rotationDeg = (angle * 180 / Math.PI) + 90;
                shard.style.setProperty('--rotation-angle', `${rotationDeg}deg`);
                shard.style.transform = `rotate(${rotationDeg}deg)`;
                
                DOM.shardsContainer.appendChild(shard);
            }
        }
        
        /**
         * Marks a single shard as received and positions it in the outer orbit
         * @param {HTMLElement} shard - The shard element to mark
         * @param {boolean} isHighlighted - Whether to highlight this shard
         * @param {boolean} isRescan - Whether this is a rescanned shard
         */
        function markShardReceived(shard, isHighlighted = false, isRescan = false) {
            const angle = parseFloat(shard.dataset.angle);
            const rotationDeg = (angle * 180 / Math.PI) + 90;
            
            // Set rotation and position in outer orbit
            shard.style.setProperty('--rotation-angle', `${rotationDeg}deg`);
            shard.style.transform = `rotate(${rotationDeg}deg)`;
            shard.classList.add('received');
            
            // Position in outer orbit
            const x = LAYOUT.CENTER_X + LAYOUT.OUTER_RADIUS * Math.cos(angle) - LAYOUT.SHARD_OFFSET_X;
            const y = LAYOUT.CENTER_Y + LAYOUT.OUTER_RADIUS * Math.sin(angle) - LAYOUT.SHARD_OFFSET_Y;
            
            shard.style.left = `${x}px`;
            shard.style.top = `${y}px`;
            
            // Handle highlighting
            shard.classList.remove('latest', 'rescanned');
            if (isHighlighted) {
                if (isRescan) {
                    shard.classList.add('rescanned');
                    shard.style.animation = 'bounce 0.6s ease-out';
                    setTimeout(() => { shard.style.animation = ''; }, 600);
                } else {
                    shard.classList.add('latest');
                }
            }
        }
        
        /**
         * Updates shard indicators based on received parts
         * @param {boolean} isRescan - Whether this update is for a rescanned part
         */
        function updateShardIndicators(isRescan = false) {
            const shards = DOM.shardsContainer.querySelectorAll('.shard');
            shards.forEach(shard => {
                const part = parseInt(shard.dataset.part);
                const angle = parseFloat(shard.dataset.angle);
                const rotationDeg = (angle * 180 / Math.PI) + 90;
                
                shard.style.setProperty('--rotation-angle', `${rotationDeg}deg`);
                shard.style.transform = `rotate(${rotationDeg}deg)`;
                shard.classList.remove('latest', 'rescanned');
                
                if (state.receivedShares[part]) {
                    // Use the shared function for received shards
                    const isLatest = (part === state.latestReceivedPart);
                    markShardReceived(shard, isLatest, isRescan);
                } else {
                    // Position unreceived shard in inner orbit
                    const x = LAYOUT.CENTER_X + LAYOUT.INNER_RADIUS * Math.cos(angle) - LAYOUT.SHARD_OFFSET_X;
                    const y = LAYOUT.CENTER_Y + LAYOUT.INNER_RADIUS * Math.sin(angle) - LAYOUT.SHARD_OFFSET_Y;
                    
                    shard.style.left = `${x}px`;
                    shard.style.top = `${y}px`;
                }
            });
        }

        // ===== DATA PROCESSING =====

        /**
         * Handles QR code scan results
         * @param {Object} result - Scan result with data property containing the QR content
         */
        async function handleQrScan(result) {
            // Skip if no data
            if (!result || !result.data) return;
            
            const decodedText = result.data;
            
            // Skip duplicate scans
            if (decodedText === state.lastScanned) return;
            state.lastScanned = decodedText;
            
            try {
                const qrData = JSON.parse(decodedText);
                
                // Validate QR code format
                if (!qrData.id || !qrData.part || !qrData.total || !qrData.originalBlobs || 
                    !qrData.data || !qrData.checksum || !qrData.fullChecksum) {
                    return;
                }
                
                // Initialize or reset transfer if new ID encountered
                if (!state.transferId || state.transferId !== qrData.id) {
                    if (state.transferId) resetTransfer();
                    
                    state.transferId = qrData.id;
                    state.totalShares = qrData.total;
                    state.originalBlobs = qrData.originalBlobs;
                    state.allowedFailures = qrData.allowedFailures;
                    state.expectedFullChecksum = qrData.fullChecksum;
                    state.originalSize = qrData.originalSize;
                    createShardIndicators(state.totalShares);
                }
                
                // Verify the part's checksum
                const calculatedChecksum = await calculateSHA256(qrData.data);
                if (calculatedChecksum !== qrData.checksum) return;
                
                // Process the share
                if (!state.receivedShares[qrData.part]) {
                    // New share
                    state.receivedShares[qrData.part] = qrData.data;
                    state.latestReceivedPart = qrData.part;
                    updateShardIndicators();

                    // Check if we have enough shares to reconstruct
                    const receivedCount = Object.keys(state.receivedShares).length;
                    if (receivedCount >= state.originalBlobs + state.allowedFailures) {
                        await reconstructSecret();
                    }
                } else {
                    // Rescanned share
                    state.latestReceivedPart = qrData.part;
                    updateShardIndicators(true);
                }
            } catch (error) {
                console.error("Error processing QR code:", error);
            }
        }
        
        /**
         * Reconstructs and verifies the secret from collected shares
         */
        async function reconstructSecret() {
            try {
                // Convert shares back to Uint8Arrays and place in correct positions
                const encodedShares = new Array(state.totalShares);
                const shareKeys = Object.keys(state.receivedShares);

                // Place shares in their correct positions
                let shareSize;
                for (const key of shareKeys) {
                    const partIndex = parseInt(key) - 1; // Convert part number to 0-indexed
                    const shareData = state.receivedShares[key];
                    encodedShares[partIndex] = base64ToUint8Array(shareData);
                    shareSize = encodedShares[partIndex].length;
                }

                // Fill each non-filled share with a placeholder of the correct size
                for (let i = 0; i < encodedShares.length; i++) {
                    if (!encodedShares[i]) {
                        encodedShares[i] = new Uint8Array(shareSize);
                    }
                }

                // Use erasure.js to recombine the shards
                const reconstructedData = erasure.recombine(
                    encodedShares,
                    state.originalSize,
                    state.originalBlobs,
                    state.allowedFailures
                );

                // Verify the reconstructed data with the checksum
                const base64ReconstructedData = uint8ArrayToBase64(reconstructedData);
                const calculatedFullChecksum = await calculateSHA256(base64ReconstructedData);

                if (calculatedFullChecksum !== state.expectedFullChecksum) {
                    console.error("Checksum verification failed");
                    return;
                }
                
                // Decompress the data
                const decompressedBytes = fflate.unzlibSync(reconstructedData);
                const decompressedString = fflate.strFromU8(decompressedBytes);
                state.fullData = decompressedString;
                
                // Mark all shards as received
                const shards = DOM.shardsContainer.querySelectorAll('.shard');
                shards.forEach(shard => markShardReceived(shard));
                
                // Update UI and cleanup
                if (state.qrScanner) {
                    state.qrScanner.stop();
                }
                
                // Show completion state
                DOM.cameraContainer.style.display = 'none';
                DOM.scannerGlow.style.display = 'none';
                DOM.completionCircle.style.display = 'flex';
                
                // Process the reconstructed data locally instead of sending to server
                processReconstructedData(state.fullData);
            } catch (error) {
                console.error("Error reconstructing secret:", error);
            }
        }
        
        /**
         * Processes the reconstructed data to verify and display the transaction
         * @param {string} data - The reconstructed JSON data
         */
        function processReconstructedData(data) {
            try {
                // Parse the transaction
                const tx = JSON.parse(data);
                
                // Verify the transaction
                const result = verifyTransaction(tx, { verbose: true });
                
                // Display the verification result
                displayVerificationResult(result);
                
                // Display success message
                const successMessage = document.querySelector('.success-message');
                successMessage.style.opacity = '1';
            } catch (error) {
                console.error("Error processing data:", error);
                
                // Show error message
                const successMessage = document.querySelector('.success-message');
                successMessage.textContent = 'Error processing data. See console for details.';
                successMessage.style.color = '#FF5252';
                successMessage.style.opacity = '1';
            }
        }
        
        /**
         * Displays the verification result in the UI
         * @param {Object} result - The verification result object
         */
        function displayVerificationResult(result) {
            // Use our new modern UI component
            const verificationElement = createVerificationResult(result);
            
            // Add the result container to the DOM
            DOM.verificationResult.innerHTML = '';
            DOM.verificationResult.appendChild(verificationElement);
        }
        
        /**
         * Resets the transfer state
         */
        function resetTransfer() {
            state.transferId = null;
            state.receivedShares = {};
            state.originalBlobs = 0;
            state.allowedFailures = 0;
            state.totalShares = 0;
            state.fullData = null;
            state.expectedFullChecksum = null;
            state.latestReceivedPart = null;
            state.originalSize = 0;
            DOM.shardsContainer.innerHTML = '';
        }
        
        // ===== EVENT HANDLERS =====
        document.addEventListener('DOMContentLoaded', () => {
            initializeScanner();
        });
    </script>
</body>
</html>